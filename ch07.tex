\chapter{Communication Complexity}

\section*{Lecture 28: Communication complexity: definitions and examples}

Model:

\begin{itemize}
    \item Finite sets $X, Y, Z$
    \item A function $f: X \times Y \rightarrow Z$
    \item Two ``players'': Alice and Bob, know $X, Y, Z, f$
    \item Decide on a communication protocol
    \item Alice gets $x \in X$, Bob gets $y \in Y$
\end{itemize}

Goal: compute $f(x, y)$ by sending bits back and forth. Must end with \emph{both} of them knowing $f(x, y)$. How many bits does it take?

Notes:

\begin{itemize}
    \item We ignore computation time (or space) of Alice \& Bob.
    \item Alice \& Bob coopratively execute the protocol.
    \item All communication is perfect. No noise, eavesdroppers, etc.
\end{itemize}

\begin{example}
    Let $X = Y = \set{0, 1}^n, Z = \set{0, 1}$. Consider the function

    \begin{dmath*}
        EQ_n(x, y) =
        \begin{cases}
            1, \text{if } x = y\\
            0, \text{otherwise}
        \end{cases}
    \end{dmath*}
\end{example}

Protocol: Alice sends $x$ to Bob ($n$ bits). Bob computes $EQ_n(x, y)$, sends this to Alice (1 bit).

Total: $n + 1$ bits of computation. This is completely optimal (even the $+1$).

\begin{example}
    $X, Y, Z$ same as before. Let

    \begin{dmath*}
        PARIITY_n(x, y) =
        \begin{cases}
            1, \text{if there are an odd \# of 1s in $x$ and $y$} \\
            0, \text{otherwise}
        \end{cases}
    \end{dmath*}
\end{example}

Protocol:

\begin{itemize}
    \item Alice sends the $\sum x_i$ to Bob. ($\log(n)$ bits)
    \item Bob sends $\sum y_i$ to Alice. ($\log(n)$ bits)
    \item (Total: $2\log(n)$ bits)
    \item Output the xor of those parity values
\end{itemize}

Question: How many bits needed to represent a value $v \in \set{0, \ldots, n}$.

Answer: $\floor{\log_2(n) + 1} \approx \lg_2(n)$.

\begin{example}
    Suppose $U = \set{1, \ldots, n}$ and $v_1: 2^U \rightarrow \set{0, 1}$. How many bits does it take to send $v_i$ to Bob?

    Answer: $2^n$.
\end{example}

\begin{example}
    The Trivial Protocol

    Protocol:

    \begin{itemize}
        \item Alice sends $x$ to Bob ($\lg\abs{x}$).
        \item Bob computes $z: f(x, y)$.
        \item Bob sends $z$ to Alice ($\lg\abs{z}$)
    \end{itemize}

    Total: $\lg\abs{x} + lg\abs{z}$.
\end{example}

\section*{Lecture 29: Protocol trees, Deterministic communication complexity, Monochromatic rectangles}

A \emph{communication protocol} is a binary tree where each node $v$ is labelled by either:

\begin{itemize}
    \item a function $a_v: x \rightarrow \set{L, R}$
    \item or a function $b_v: y \rightarrow \set{L, R}$
\end{itemize}

And each leaf is labelled by an element of $z$.

\emph{Observation}: Depth of protocol tree = max, over all inputs, of \# of bits sent by protocol

\begin{definition}
    The (deterministic) communication complexity of a function $f$ is $\underbrace{\min}_{\substack{\text{protocol tree} \\ \text{computing} f}} (\text{depth of tree})$
\end{definition}

What is $D(EQ_2)$? The slide tells use $D(EQ_2) \leq 40$. Second slide tells us $D(EQ_2) \leq 3$. More generally, $D(EQ_2) \leq n + 1$. $EQ_n : \set{0, 1}^n \times \set{0, 1}^n \Rightarrow \set{0, 1}$.

\begin{definition}
    A \emph{rectangle} in $X \times Y$ is a set of the form $R = A \times B$ where $A \subseteq X, B \subseteq Y$.
\end{definition}

\emph{Observation}: $R$ is a rectangle iff $(x, y) \in R \wedge (x', y') \in R \Rightarrow (x, y') \in R \wedge (x', y) \in R$.

\emph{Claim}:  Let $T$ be a protocol tree. Let $R_v$ be a set of inputs that cause the protocol to arrive at node $v$. Then $R_v$ is a rectangle.

\emph{Sketch}: $R_{root} = X \times Y$ (a rectangle). Each node where Alice communicates eliminates some rows. $\ldots$ Bob $\ldots$. Both of these preserve rectangleness.

\begin{definition}
    A rectangle $R \subseteq X \times Y$ is called \emph{f-monochromatic} if $f(x, y)$ is the same for all $(x, y) \in R$.
\end{definition}

\begin{definition}
    Let $R_i \subseteq X \times Y$ be a rectangle for $i = 1 \ldots k$. The set $R = \set{R_i, \ldots, R_k}$ is called a f-monochromatic partition (into rectangles) if:

    \begin{itemize}
        \item each $R_i$ is f-monochromatic
        \item each $(x, y) \in X \times Y$ is contained in exactly one $R_i$
    \end{itemize}

    Here $\abs{R} = k = \#$ of rectangles in it.
\end{definition}

\begin{definition}
    $C^{partition}(f) = \min \set{\abs{R}: R \text{ is a f-monochromatic partition}}$.
\end{definition}

\emph{Claim}: For any protocol tree $T$, the rectangles $\set{R_v, v \text{ is a leaf in } T}$ are a f-monochromatic partition.

\begin{corollary}
    $C^{partition}(f) \underbrace{\min}_{\text{protocol tree } T} \abs{\# \text{ of leaves in } T}$.
\end{corollary}

\section*{Lecture 30: Tight analysis of EQ, Fooling sets}

\emph{Recall}: For any binary tree $T$, \# leaves of $T \leq 2^{depth(T)}$.

\begin{corollary}
    For any protocol tree $T$, $C^{parition}(f) \leq \#$ leaves of $T \leq 2^{depth(T)}$.
\end{corollary}

Taking log: $\log_2C^{parition}(f) \leq depth(T)$. Letting $T$ be the minimum-depth protocol tree computing $f$,

\begin{dmath*}
    \underbrace{\log_2C^{parition}(f)}_{\text{can take ceiling ``for free''}} \leq \underbrace{\min \set{depth(T): \text{protocol tree } T \text{ for } f} = D(f)}_{\text{this is an integer}}
\end{dmath*}

\emph{Claim}: $C^{partition}(EQ_2) \geq 5$.

$\Rightarrow \ceil{\lg_2 C^{parition}(EQ_2)} \geq \ceil{\lg_2 5} = 3$. Using claim: $D(EQ_2) \geq 3$. We already saw $D(EQ_2) \leq 3$, Trivial Protocol so $D(EQ_2) = 3$ i.e. Trivial Protocol is optimal. Consider a Trivial Protocol for $EQ_2$

Let $f: X \times Y \rightarrow \set{0, 1}$ be a function.

\begin{definition}
    Let $S$ be a subset of $X \times Y$. Suppose:

    \begin{itemize}
        \item all points $(x, y) \in S$ have the same value $f(x, y) = Z$.
        \item for any distinct points $(x, y)$ and $(x', y')$ in $S$, either $f(x, y') \neq Z$ or $f(x', y) \neq Z$.
    \end{itemize}

    Then $S$ is called a \emph{fooling set} for $f$.
\end{definition}

\begin{example}
    With $EQ_2$, the diagonal entires are a fooling set.

    \emph{Observation 1}: Any two entries of a fooling set must lie in distinct rows \& columns. (e.g. if $x = x'$ then $f(x, y') = f(x', y')$, so it doesn't work).

    \emph{Observation 2}: Any two elements of a fooling set cannot lie in the same monochromatic rectangle.
\end{example}

\begin{corollary}
    If $f$ has a fooling set of size $k$, then any $f$-monochromatic partition needs $\geq k$ rectangles, even just to cover the $z$-entries. And one more rectangle to cover the non-$z$-entries. So $C^{partition}(f) \geq k + 1$ (assuming there is a non-$z$-entry).
\end{corollary}

\begin{corollary}
    If $S$ is a fooling set with $\abs{S} = u$, then $D(f) \geq \ceil{\lg_2(k + 1)}$.
\end{corollary}

$S$ is a fooling set. $\abs{S} = 2^n$. So $D(EQ_n) \geq \ceil{\lg_2(2^n + 1)} = n + 1$. Again Trivial Protocol gives $D(EQ_n) \leq n + 1$.
